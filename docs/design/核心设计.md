​	

## 前言

​	我们的应用（尤其是大型应用）往往依赖许多第三方组件（日志、缓存、ORM等等），需要配置项繁多，所有的东西积压在Program或Startup（参考EShop），相当混乱（要知道Startup不仅要承载容器的配置，还要负责管道模型的组装），有些聪明的同学可能会按照内容相关性来提取方法，或者是抽象类，来增强他们的可读性、可维护性，这不失是一种好的解决方案，但直到我在ABP学习到了模块化这个概念，我想，这才是终极解决方案。

​	配置不再被积压在程序入口，而是被分摊到各个层（模块），每层只配置自己关注的内容。比如基础设施层（数据访问层）会与数据库交互，那么与数据库交互的组件配置我们就放这层就好了，在服务层（业务逻辑层）我们可能会用到实体之间映射的组件，他们也只需配置自己关注的内容即可。而此时，基础设施层就像一个已经提供好的能力一样被服务层依赖，服务层不需要关心基础设施是依赖的谁，数据库用的是MySql还是SqlServer，ORM使用的是EF还是Sugar。。。

​	Fake也贯彻了模块化和依赖注入的思想（依赖注入也是AspNetCore框架贯彻始终的一个设计模式），这样的好处相信不用我多说，其实AspNetCore相较于Framework最大的区别之一就是前者是后者的解体，只是AspNetCore并没有提供模块化的落地（他自己模块化了，不管用他的应用是不是模块化的~），小项目可以一把梭哈，维护过大型项目的同学想必都不敢乱动那一座**。



## 模块化

模块化（Modularity）是一种软件设计原则和方法，它将复杂的系统划分为相互独立的模块或组件，每个模块负责完成特定的功能或任务。模块化的目标是提高软件的可维护性、可重用性和可扩展性。

在模块化设计中，一个模块通常具有以下特点：

1. 独立性：模块是相对独立的，它们可以独立开发、测试和维护。模块之间通过定义清晰的接口进行通信，而不需要了解彼此的内部实现细节。
2. 封装性：模块将相关的数据和功能封装在一起，对外部提供有限的接口，隐藏了内部的实现细节。这样可以提高代码的安全性和可靠性，并减少模块之间的耦合。
3. 可重用性：模块可以被多个系统或应用程序共享和重复使用。通过模块化设计，可以将通用的功能封装成模块，以便在不同的项目中进行复用，提高开发效率和代码质量。
4. 可扩展性：模块化设计使得系统可以更容易地进行扩展和修改。当需要添加新的功能或修改现有功能时，只需要修改或添加相应的模块，而不需要对整个系统进行大规模的改动。
5. 可测试性：模块化设计使得单元测试和集成测试更加容易。由于模块之间的独立性，可以更方便地对每个模块进行测试，减少了测试的复杂性和成本。



### 命名约定

每一个项目（dll），都建议在项目目录下建立一个类继承自`FakeModule`，命名按照项目名去除.加上后缀`Module`，例如：`Fake.Core -> FakeCoreModule`

```
class FakeCoreModule : FakeModule
```



### 模块Hook

Fake模块提供七个空hook，分别对应`Startup`的`ConfigureServices`、`Configure`的执行前、执行时、执行后，以及模块销毁时`Shutdown`，可以根据自己需求重写即可

```c#
public virtual void PreConfigureServices(ServiceConfigurationContext context)

public virtual void ConfigureServices(ServiceConfigurationContext context)

public virtual void PostConfigureServices(ServiceConfigurationContext context)

public virtual void PreConfigureApplication(ApplicationConfigureContext context)

public virtual void ConfigureApplication(ApplicationConfigureContext context)

public virtual void PostConfigureApplication(ApplicationConfigureContext context)

public virtual void Shutdown(ApplicationShutdownContext context)
```



### 模块依赖

使用`DependsOnAttribute`来依赖其它模块，任何`FakeModule`都能够依赖或是被依赖，入口就是你的启动模块（启动程序）

```c#
[DependsOn(typeof(CustomModule))]
public class StartupModule : FakeModule {}
public class CustomModule : FakeModule {}
```



### 模块加载

**模块加载能力** 由IModuleLoader提供，你可以自行实现并替换之

```c#
public interface IModuleLoader
{
    [NotNull]
    IModuleDescriptor[] LoadModules(
        [NotNull] IServiceCollection services,
        [NotNull] Type startupModuleType
    );
}
```

**模块Hook** 会受加载顺序影响（洋葱模型），模块的加载顺序默认实现使用 **topology排序** 确定没有循环依赖，与类的构造顺序保持一致，被依赖项先执行，即满足如果A依赖B，则B先被加载。



## 依赖注入

依赖注入（Dependency Injection，简称DI）是一种设计模式，用于解耦组件之间的依赖关系。它通过将依赖关系的创建和管理交给外部容器来实现，而不是在组件内部直接创建依赖对象。