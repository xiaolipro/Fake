​	

## 前言

​	我们的应用（尤其是大型应用）往往依赖许多第三方组件（日志、缓存、ORM等等），需要配置项繁多，所有的东西积压在Program或Startup（参考EShop），相当混乱（要知道Startup不仅要承载容器的配置，还要负责管道模型的组装），有些聪明的同学可能会按照内容相关性来提取方法，或者是抽象类，来增强他们的可读性、可维护性，这不失是一种好的解决方案，但直到我在ABP学习到了模块化这个概念，我想，这才是终极解决方案。

​	配置不再被积压在程序入口，而是被分摊到各个层（模块），每层只配置自己关注的内容。比如基础设施层（数据访问层）会与数据库交互，那么与数据库交互的组件配置我们就放这层就好了，在服务层（业务逻辑层）我们可能会用到实体之间映射的组件，他们也只需配置自己关注的内容即可。而此时，基础设施层就像一个已经提供好的能力一样被服务层依赖，服务层不需要关心基础设施是依赖的谁，数据库用的是MySql还是SqlServer，ORM使用的是EF还是Sugar。。。

​	Fake也贯彻了模块化和依赖注入的思想（依赖注入也是AspNetCore框架贯彻始终的一个设计模式），这样的好处相信不用我多说，其实AspNetCore相较于Framework最大的区别之一就是前者是后者的解体，只是AspNetCore并没有提供模块化的落地（他自己模块化了，不管用他的应用是不是模块化的~），小项目可以一把梭哈，维护过大型项目的同学想必都不敢乱动那一座**。



## FakeApplication

我们观察.NET架构会察觉，不论是控制台程序、Web应用、还是单元测试等等，他们都有一些公共特质：他们都是一个主机程序，他们都可以贯彻依赖注入和控制翻转的设计模式。

> ​	我尤其想说的是，虽然Fake探寻的是Web应用下的最佳实践，但这不不代表Fake仅服务于**Web应用**，否则在**标准流程**中传递的就不会是IServiceProvider，而是IApplicationBuilder了。事实上你会发现这样的抽象是合理的，复杂如Web应用，简单如控制台程序，他们都遵循这一套公共特质，而这样的的特质放在FakeCore在适合不过了。
>
> ​	如果看过IApplicationBuilder源码的同学应该清楚，实现一个所谓的管道模型，是多么的简单，真正复杂的是Microsoft.NET.Sdk.Web以及AspNetCore提供的一系列拓展，这些基础设施我们没有必要也没有精力去开发，完全可以站在他们的肩膀上。在我们的核心模块开发中，会尽力避免引入第三方，优先使用Microsoft.Extensions，亲和官方，是我们的第一原则



### 控制台用法

使一个应用变成`FakeApplication`非常简单：

```c#
static void Main(string[] args)
{
    using var application = FakeApplicationFactory.Create<SimpleConsoleDemoModule>(); // 1.构造FakeApplication
    application.InitializeApplication(); // 2.初始化FakeApplication
    
    logger.LogInformation("Initializing the application... OK");
    // do something
}
```



### Web用法

```c#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddFakeApplication<SimpleWebDemoModule>(); // 1.构造FakeApplication
var app = builder.Build();
app.InitializeApplication(); // 2.初始化FakeApplication

app.MapGet("/", () => "Hello World!");
app.Run();
```

web应用是长时间运行的，FakeApplication的生命周期挂载在`IApplicationBuilder`，与其同消亡

```c#
var application = app.ApplicationServices.GetRequiredService<FakeApplication>();
var applicationLifetime = app.ApplicationServices.GetRequiredService<IHostApplicationLifetime>();
applicationLifetime.ApplicationStopped.Register(() => application.Dispose());
```



### FakeApplication

`FakeApplication`的构造由`FakeApplicationFactory`提供，Faker只需要关注构造参数

```c#
internal FakeApplication(
        [NotNull] Type startupModuleType,
        [NotNull] IServiceCollection services,
        [CanBeNull] Action<FakeApplicationCreationOptions> optionsAction)
```

1. startupModuleType：启动模块
2. services：服务容器
3. optionsAction：FakeApplication的创建配置



### 代码流

整个Fake的生命周期环绕IServiceCollection、IServiceProvider展开，以Module落地

**构造FakeApplication的代码流：**

1. 生成服务容器
2. 执行optionsAction
3. 添加配置（官方配置）
   - 添加json文件
   - 根据当前环境添加json文件
   - 添加开发环境下的用户机密
   - 添加命令行参数
4. 添加日志（官方日志）
   - 读取配置节点Logging
   - 打印到控制台
5. 加载Fake模块
6. 执行ConfigureService
   - PreConfigureServices
   - ConfigureServices
   - PostConfigureServices

**InitializeApplication的代码流：**

1. 生成服务供应商（如果没有就用默认的）
2. 执行Configure
   - PreConfigureApplication
   - ConfigureApplication
   - PostConfigureApplication



## 模块化

模块化（Modularity）是一种软件设计原则和方法，它将复杂的系统划分为相互独立的模块或组件，每个模块负责完成特定的功能或任务。模块化的目标是提高软件的可维护性、可重用性和可扩展性。

在模块化设计中，一个模块通常具有以下特点：

1. 独立性：模块是相对独立的，它们可以独立开发、测试和维护。模块之间通过定义清晰的接口进行通信，而不需要了解彼此的内部实现细节。
2. 封装性：模块将相关的数据和功能封装在一起，对外部提供有限的接口，隐藏了内部的实现细节。这样可以提高代码的安全性和可靠性，并减少模块之间的耦合。
3. 可重用性：模块可以被多个系统或应用程序共享和重复使用。通过模块化设计，可以将通用的功能封装成模块，以便在不同的项目中进行复用，提高开发效率和代码质量。
4. 可扩展性：模块化设计使得系统可以更容易地进行扩展和修改。当需要添加新的功能或修改现有功能时，只需要修改或添加相应的模块，而不需要对整个系统进行大规模的改动。
5. 可测试性：模块化设计使得单元测试和集成测试更加容易。由于模块之间的独立性，可以更方便地对每个模块进行测试，减少了测试的复杂性和成本。



### 命名约定

每一个项目（dll），都建议在项目目录下建立一个类继承自`FakeModule`，命名按照项目名去除.加上后缀`Module`，例如：`Fake.Core -> FakeCoreModule`

```
class FakeCoreModule : FakeModule
```



### 模块Hook

Fake模块提供七个空hook，分别对应`Startup`的`ConfigureServices`、`Configure`的执行前、执行时、执行后，以及模块销毁时`Shutdown`，可以根据自己需求重写即可

```c#
public virtual void PreConfigureServices(ServiceConfigurationContext context)

public virtual void ConfigureServices(ServiceConfigurationContext context)

public virtual void PostConfigureServices(ServiceConfigurationContext context)

public virtual void PreConfigureApplication(ApplicationConfigureContext context)

public virtual void ConfigureApplication(ApplicationConfigureContext context)

public virtual void PostConfigureApplication(ApplicationConfigureContext context)

public virtual void Shutdown(ApplicationShutdownContext context)
```

所谓的模块化落地就是将传统的`Startup`集中式配置，转变成了洋葱圈式按需配置，你可以理解为一个模块就是一个`Startup`，他们被Fake来串联，始于启动模块，**依赖**N个模块，最终得到的就是完整的`Startup`。

### 模块依赖

使用`DependsOnAttribute`来依赖其它模块，任何`FakeModule`都能够依赖或是被依赖，入口就是你的启动模块（启动程序）

```c#
[DependsOn(typeof(CustomModule))]
public class StartupModule : FakeModule {}
public class CustomModule : FakeModule {}
```



### 模块加载

**模块加载能力** 由IModuleLoader提供，你可以自行实现并替换之

```c#
public interface IModuleLoader
{
    [NotNull]
    IModuleDescriptor[] LoadModules(
        [NotNull] IServiceCollection services,
        [NotNull] Type startupModuleType
    );
}
```

**模块Hook** 会受加载顺序影响（洋葱模型），模块的加载顺序默认实现使用 **topology排序** 确定没有循环依赖，与类的构造顺序保持一致，被依赖项先执行，即满足如果A依赖B，则B先被加载。



## 依赖注入

依赖注入（Dependency Injection，简称DI）是一种设计模式，用于解耦组件之间的依赖关系。它通过将依赖关系的创建和管理交给外部容器来实现，而不是在组件内部直接创建依赖对象。

这种设计被贯穿于AspNetCore，Fake自然不会放过，在其基础上，我们还提供了自动注入能力。

服务实现一旦实现**Fake提供的服务生命周期**（`ITransientDependency`、`IScopedDependency`、`ISingletonDependency`），就会被自动注入到IOC容器中（Fake使用的是Autofac来取代原生容器）并指定相应生命周期



### 服务注册流程

服务注册能力由`AbstractServiceRegistrar`提供，默认的服务注册流程如下：

- 判断是否要跳过流程
- 获取服务生命周期
- 获取需要暴露的服务
- 触发服务暴露动作
- 将需要暴露的服务注册到容器



### 服务暴露约定

服务暴露能力由`IExposedServiceTypesProvider`提供，有以下约定：

- 实现本身会被暴露

- 按照约定命名的接口会被暴露：擦除开头的I，匹配服务后缀的。

  ```c#
  // MyA、IA 会被暴露，生命周期为单例
  public interface IA : ISingletonDependency {}
  public class MyA : IA
  ```

- 暴露`ExposeServicesAttribute`提供的服务

  ```c#
  // 暴露 X、IB
  public interface IB {}
  [ExposeServices(typeof(IB))]
  public class X : IB, IScopedDependency {}
  ```

不会被暴露服务：

- 不符合上述约定的服务

- 无法获取**Fake提供的服务生命周期**的服务

  - 优先从`DependencyAttribute`读取

  - 其次是从类的层次体系中读取**Fake提供的服务生命周期**，当层次体系拥有多个不同生命周期时，`ITransientDependency`>`IScopedDependency`>`ISingletonDependency`

    ```c#
    // DifferentLife、IDifferentLife 会被暴露，生命周期为ServiceLifetime.Singleton
    public interface IDifferentLife : ISingletonDependency {}
    public class DifferentLife: IDifferentLife, ITransientDependency {}
    ```

- 局部禁止：标记`DisableServiceRegistrationAttribute`

  ```c#
  [DisableServiceRegistration]
  public class MyA : IA  // MyA、IA 不会被暴露
  ```

- 模块内禁止：重写模块属性`SkipServiceRegistration`

  ```c#
  public class FakeCoreModule : FakeModule
  {
      // 当赋值为true时 跳过Fake提供的自动服务注册
      public override bool SkipServiceRegistration => true;
  }
  ```



> 非Transient生命周期的暴露集，元素大于1时会产生**实现重定向**
>
> 如果实现自爆了，则所有暴露都重定向到实现，否则重定向到第一个可分配的暴露



