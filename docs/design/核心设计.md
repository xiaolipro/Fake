​	

## 前言

​	我们的应用（尤其是大型应用）往往依赖许多第三方组件（日志、缓存、ORM等等），需要配置项繁多，所有的东西积压在Program或Startup（参考EShop），相当混乱（要知道Startup不仅要承载容器的配置，还要负责管道模型的组装），有些聪明的同学可能会按照内容相关性来提取方法，或者是抽象类，来增强他们的可读性、可维护性，这不失是一种好的解决方案，但直到我在ABP学习到了模块化这个概念，我想，这才是终极解决方案。

​	配置不再被积压在程序入口，而是被分摊到各个层（模块），每层只配置自己关注的内容。比如基础设施层（数据访问层）会与数据库交互，那么与数据库交互的组件配置我们就放这层就好了，在服务层（业务逻辑层）我们可能会用到实体之间映射的组件，他们也只需配置自己关注的内容即可。而此时，基础设施层就像一个已经提供好的能力一样被服务层依赖，服务层不需要关心基础设施是依赖的谁，数据库用的是MySql还是SqlServer，ORM使用的是EF还是Sugar。。。

​	Fake也贯彻了模块化和依赖注入的思想（依赖注入也是AspNetCore框架贯彻始终的一个设计模式），这样的好处相信不用我多说，其实AspNetCore相较于Framework最大的区别之一就是前者是后者的解体，只是AspNetCore并没有提供模块化的落地（他自己模块化了，不管用他的应用是不是模块化的~），小项目可以一把梭哈，维护过大型项目的同学想必都不敢乱动那一座**。



## 模块化

模块化（Modularity）是一种软件设计原则和方法，它将复杂的系统划分为相互独立的模块或组件，每个模块负责完成特定的功能或任务。模块化的目标是提高软件的可维护性、可重用性和可扩展性。

在模块化设计中，一个模块通常具有以下特点：

1. 独立性：模块是相对独立的，它们可以独立开发、测试和维护。模块之间通过定义清晰的接口进行通信，而不需要了解彼此的内部实现细节。
2. 封装性：模块将相关的数据和功能封装在一起，对外部提供有限的接口，隐藏了内部的实现细节。这样可以提高代码的安全性和可靠性，并减少模块之间的耦合。
3. 可重用性：模块可以被多个系统或应用程序共享和重复使用。通过模块化设计，可以将通用的功能封装成模块，以便在不同的项目中进行复用，提高开发效率和代码质量。
4. 可扩展性：模块化设计使得系统可以更容易地进行扩展和修改。当需要添加新的功能或修改现有功能时，只需要修改或添加相应的模块，而不需要对整个系统进行大规模的改动。
5. 可测试性：模块化设计使得单元测试和集成测试更加容易。由于模块之间的独立性，可以更方便地对每个模块进行测试，减少了测试的复杂性和成本。



### 命名约定

每一个项目（dll），都建议在项目目录下建立一个类继承自`FakeModule`，命名按照项目名去除.加上后缀`Module`，例如：`Fake.Core -> FakeCoreModule`

```
class FakeCoreModule : FakeModule
```



### 模块Hook

Fake模块提供七个空hook，分别对应`Startup`的`ConfigureServices`、`Configure`的执行前、执行时、执行后，以及模块销毁时`Shutdown`，可以根据自己需求重写即可

```c#
public virtual void PreConfigureServices(ServiceConfigurationContext context)

public virtual void ConfigureServices(ServiceConfigurationContext context)

public virtual void PostConfigureServices(ServiceConfigurationContext context)

public virtual void PreConfigureApplication(ApplicationConfigureContext context)

public virtual void ConfigureApplication(ApplicationConfigureContext context)

public virtual void PostConfigureApplication(ApplicationConfigureContext context)

public virtual void Shutdown(ApplicationShutdownContext context)
```

所谓的模块化落地就是将传统的`Startup`集中式配置，转变成了洋葱圈式按需配置，你可以理解为一个模块就是一个`Startup`，他们被Fake来串联，始于启动模块，**依赖**N个模块，最终得到的就是完整的`Startup`。

### 模块依赖

使用`DependsOnAttribute`来依赖其它模块，任何`FakeModule`都能够依赖或是被依赖，入口就是你的启动模块（启动程序）

```c#
[DependsOn(typeof(CustomModule))]
public class StartupModule : FakeModule {}
public class CustomModule : FakeModule {}
```



### 模块加载

**模块加载能力** 由IModuleLoader提供，你可以自行实现并替换之

```c#
public interface IModuleLoader
{
    [NotNull]
    IModuleDescriptor[] LoadModules(
        [NotNull] IServiceCollection services,
        [NotNull] Type startupModuleType
    );
}
```

**模块Hook** 会受加载顺序影响（洋葱模型），模块的加载顺序默认实现使用 **topology排序** 确定没有循环依赖，与类的构造顺序保持一致，被依赖项先执行，即满足如果A依赖B，则B先被加载。



## 依赖注入

依赖注入（Dependency Injection，简称DI）是一种设计模式，用于解耦组件之间的依赖关系。它通过将依赖关系的创建和管理交给外部容器来实现，而不是在组件内部直接创建依赖对象。

这种设计被贯穿于AspNetCore，Fake自然不会放过，在其基础上，我们还提供了自动注入能力。

服务实现一旦实现**Fake提供的服务生命周期**（`ITransientDependency`、`IScopedDependency`、`ISingletonDependency`），就会被自动注入到IOC容器中（Fake使用的是Autofac来取代原生容器）并指定相应生命周期



### 服务注册流程

服务注册能力由`AbstractServiceRegistrar`提供，默认的服务注册流程如下：

- 判断是否要跳过流程
- 获取服务生命周期
- 获取需要暴露的服务
- 触发服务暴露动作
- 将需要暴露的服务注册到容器



### 服务暴露约定

服务暴露能力由`IExposedServiceTypesProvider`提供，有以下约定：

- 实现本身会被暴露

- 按照约定命名的接口会被暴露：擦除开头的I，匹配服务后缀的。

  ```c#
  // MyA、IA 会被暴露，生命周期为单例
  public interface IA : ISingletonDependency {}
  public class MyA : IA
  ```

- 暴露`ExposeServicesAttribute`提供的服务

  ```c#
  // 暴露 X、IB
  public interface IB {}
  [ExposeServices(typeof(IB))]
  public class X : IB, IScopedDependency {}
  ```

不会被暴露服务：

- 不符合上述约定的服务

- 无法获取**Fake提供的服务生命周期**的服务

  - 优先从`DependencyAttribute`读取

  - 其次是从类的层次体系中读取**Fake提供的服务生命周期**，当层次体系拥有多个不同生命周期时，`ITransientDependency`>`IScopedDependency`>`ISingletonDependency`

    ```c#
    // DifferentLife、IDifferentLife 会被暴露，生命周期为ServiceLifetime.Singleton
    public interface IDifferentLife : ISingletonDependency {}
    public class DifferentLife: IDifferentLife, ITransientDependency {}
    ```

- 局部禁止：标记`DisableServiceRegistrationAttribute`

  ```c#
  [DisableServiceRegistration]
  public class MyA : IA  // MyA、IA 不会被暴露
  ```

- 模块内禁止：重写模块属性`SkipServiceRegistration`

  ```c#
  public class FakeCoreModule : FakeModule
  {
      // 当赋值为true时 跳过Fake提供的自动服务注册
      public override bool SkipServiceRegistration => true;
  }
  ```



> 非Transient生命周期的暴露集，元素大于1时会产生**实现重定向**
>
> 如果实现自爆了，则所有暴露都重定向到实现，否则重定向到第一个可分配的暴露



