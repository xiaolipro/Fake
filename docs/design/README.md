我们的应用（尤其是大型应用）往往依赖许多第三方组件（日志、缓存、ORM等等），需要配置项繁多，所有的东西积压在Program或Startup（参考EShop），相当混乱（要知道Startup不仅要承载容器的配置，还要负责管道模型的组装），有些聪明的同学可能会按照内容相关性来提取方法，或者是抽象类，来增强他们的可读性、可维护性，这不失是一种好的解决方案，但直到我在ABP学习到了模块化这个概念，我想，这才是终极解决方案。

​	配置不再被积压在程序入口，而是被分摊到各个层（模块），每层只配置自己关注的内容。比如基础设施层（数据访问层）会与数据库交互，那么与数据库交互的组件配置我们就放这层就好了，在服务层（业务逻辑层）我们可能会用到实体之间映射的组件，他们也只需配置自己关注的内容即可。而此时，基础设施层就像一个已经提供好的能力一样被服务层依赖，服务层不需要关心基础设施是依赖的谁，数据库用的是MySql还是SqlServer，ORM使用的是EF还是Sugar。。。

​	Fake也贯彻了模块化和依赖注入的思想（依赖注入也是AspNetCore框架贯彻始终的一个设计模式），这样的好处相信不用我多说，其实AspNetCore相较于Framework最大的区别之一就是前者是后者的解体，只是AspNetCore并没有提供模块化的落地（他自己模块化了，不管用他的应用是不是模块化的~），小项目可以一把梭哈，维护过大型项目的同学想必都不敢乱动那一座**。